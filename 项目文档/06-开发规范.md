# EdgeVPN 开发规范

## 1. 概述

本文档定义了 EdgeVPN 项目的开发规范，包括编码规范、命名规范、代码审查标准和文档编写规范。遵循这些规范有助于保持代码质量、提高可维护性并促进团队协作。

## 2. 编码规范

### 2.1 Go 语言规范

#### 2.1.1 代码格式

- 使用 `gofmt` 格式化所有代码
- 使用 `goimports` 管理导入
- 每行不超过 120 个字符
- 使用 tab 缩进，不使用空格

#### 2.1.2 命名约定

**包名**：
- 使用小写单词
- 简短、有意义
- 不使用下划线或驼峰命名

```go
// 好的包名
package node
package blockchain
package services

// 不好的包名
package Node
package block_chain
package myServices
```

**文件名**：
- 使用小写字母
- 使用下划线分隔单词
- 与包名保持一致

```go
// 好的文件名
node.go
blockchain.go
network_service.go

// 不好的文件名
Node.go
blockChain.go
network-service.go
```

**变量和函数名**：
- 使用驼峰命名法（首字母小写）
- 导出的变量和函数首字母大写
- 使用有意义的名称

```go
// 好的命名
var nodeCount int
func calculateHash() string
type Node struct {}

// 不好的命名
var n int
func calc() string
type N struct {}
```

**常量名**：
- 使用驼峰命名法（首字母大写）
- 或使用全大写下划线分隔

```go
// 好的常量名
const MaxConnections = 100
const DefaultTimeout = 30 * time.Second
const MAX_STREAMS = 50

// 不好的常量名
const maxConnections = 100
const default_timeout = 30 * time.Second
```

**接口名**：
- 使用动词或动词短语
- 以 -er 结尾表示动作执行者

```go
// 好的接口名
type Reader interface {}
type Writer interface {}
type StreamHandler interface {}

// 不好的接口名
type Read interface {}
type Write interface {}
type HandleStream interface {}
```

#### 2.1.3 注释规范

**包注释**：
- 每个包都应该有注释
- 注释放在 package 声明之前
- 描述包的功能和用途

```go
// Package node 提供了 EdgeVPN 网络节点的核心功能。
// 它管理 libp2p 主机、消息中心和区块链账本。
package node
```

**导出函数注释**：
- 以函数名开头
- 描述函数的功能
- 说明参数和返回值

```go
// New 创建新的节点实例
// 参数 p 为可选的配置选项
// 返回节点实例和可能的错误
func New(p ...Option) (*Node, error) {
    // ...
}
```

**导出类型注释**：
- 以类型名开头
- 描述类型的用途

```go
// Node 节点结构体，表示 EdgeVPN 网络中的一个节点
type Node struct {
    config     Config
    MessageHub *hub.MessageHub
    // ...
}
```

**导出字段注释**：
- 描述字段的用途
- 说明字段的约束

```go
type Config struct {
    // DiscoveryInterval 节点发现的时间间隔
    DiscoveryInterval time.Duration

    // MaxStreams 最大并发流数量
    MaxStreams int
}
```

**复杂逻辑注释**：
- 解释为什么这样做，而不是做什么
- 注释应该解释代码的意图

```go
// 使用 SHA256 哈希而不是 MD5，因为 SHA256 更安全
// 且性能影响可以忽略
hash := sha256.Sum256(data)
```

#### 2.1.4 错误处理

- 始终检查错误
- 使用 `errors.Wrap` 包装错误
- 提供有意义的错误信息

```go
// 好的错误处理
data, err := readFile(path)
if err != nil {
    return errors.Wrap(err, "failed to read file")
}

// 不好的错误处理
data, err := readFile(path)
if err != nil {
    return err
}
```

#### 2.1.5 并发安全

- 使用互斥锁保护共享数据
- 避免死锁
- 使用通道进行通信

```go
type Node struct {
    sync.Mutex
    data map[string]string
}

func (n *Node) SetData(key, value string) {
    n.Lock()
    defer n.Unlock()
    n.data[key] = value
}
```

### 2.2 文件组织

#### 2.2.1 文件结构

每个文件应该只包含一个主要类型或一组相关的函数。

```go
// node.go - 节点核心功能
package node

import (
    // 标准库导入
    "context"
    "fmt"

    // 第三方库导入
    "github.com/libp2p/go-libp2p"

    // 项目内部导入
    "github.com/mudler/edgevpn/pkg/config"
)

// 常量定义
const (
    defaultChanSize = 3000
)

// 类型定义
type Node struct {
    // ...
}

// 接口定义
type NetworkService func(context.Context, Config, *Node, *blockchain.Ledger) error

// 公共方法
func New(p ...Option) (*Node, error) {
    // ...
}

// 私有方法
func (n *Node) start() error {
    // ...
}
```

#### 2.2.2 导入顺序

1. 标准库
2. 第三方库
3. 项目内部包

```go
import (
    // 标准库
    "context"
    "fmt"
    "time"

    // 第三方库
    "github.com/libp2p/go-libp2p"
    "github.com/pkg/errors"

    // 项目内部
    "github.com/mudler/edgevpn/pkg/config"
    "github.com/mudler/edgevpn/pkg/logger"
)
```

### 2.3 代码复杂度

- 函数长度不超过 50 行
- 圈复杂度不超过 10
- 嵌套深度不超过 4 层

## 3. 命名规范

### 3.1 变量命名

- 使用有意义的名称
- 避免缩写（除非是通用缩写）
- 布尔变量以 `is`、`has`、`can` 开头

```go
// 好的变量名
var isConnected bool
var hasPermission bool
var canConnect bool
var maxConnections int

// 不好的变量名
var conn bool
var perm bool
var maxConn int
```

### 3.2 函数命名

- 使用动词或动词短语
- 返回布尔值的函数以 `is`、`has`、`can` 开头
- 获取数据的函数以 `get` 开头
- 设置数据的函数以 `set` 开头

```go
// 好的函数名
func isConnected() bool
func hasPermission() bool
func getConnection() *Connection
func setConnection(conn *Connection)
func calculateHash() string

// 不好的函数名
func conn() bool
func perm() bool
func conn() *Connection
func hash() string
```

### 3.3 常量命名

- 使用有意义的名称
- 避免魔法数字
- 将相关常量分组

```go
// 好的常量定义
const (
    // 默认配置
    DefaultTimeout = 30 * time.Second
    DefaultMaxConnections = 100

    // 协议版本
    ProtocolVersion = "0.1"

    // 错误消息
    ErrConnectionFailed = "connection failed"
)

// 不好的常量定义
const (
    T = 30
    M = 100
    V = "0.1"
)
```

## 4. 代码审查标准

### 4.1 审查清单

#### 4.1.1 功能性

- [ ] 代码实现了需求的功能
- [ ] 边界条件得到处理
- [ ] 错误处理完善
- [ ] 资源正确释放

#### 4.1.2 代码质量

- [ ] 代码遵循项目规范
- [ ] 变量和函数命名清晰
- [ ] 注释充分且准确
- [ ] 没有重复代码
- [ ] 代码复杂度合理

#### 4.1.3 性能

- [ ] 没有明显的性能问题
- [ ] 避免不必要的内存分配
- [ ] 合理使用并发
- [ ] 没有资源泄漏

#### 4.1.4 安全性

- [ ] 输入验证充分
- [ ] 敏感数据不泄露
- [ ] 加密使用正确
- [ ] 权限检查完善

#### 4.1.5 测试

- [ ] 单元测试覆盖充分
- [ ] 测试用例有意义
- [ ] 边界条件有测试
- [ ] 错误场景有测试

### 4.2 审查流程

1. **提交 Pull Request**
   - 描述变更的目的
   - 关联相关的 Issue
   - 提供测试结果

2. **自动检查**
   - CI/CD 自动运行测试
   - 代码格式检查
   - 静态代码分析

3. **人工审查**
   - 至少一名维护者审查
   - 提出修改建议
   - 讨论技术方案

4. **修改和完善**
   - 根据反馈修改代码
   - 更新测试
   - 响应审查意见

5. **合并**
   - 所有审查通过
   - CI/CD 检查通过
   - 合并到主分支

### 4.3 审查标准

- **必须修复**：功能错误、安全问题、性能严重问题
- **建议修复**：代码风格、命名、注释
- **可选改进**：性能优化、代码重构

## 5. 文档编写规范

### 5.1 代码文档

#### 5.1.1 包文档

每个包都应该有包级文档，说明包的功能和用途。

```go
// Package node 提供了 EdgeVPN 网络节点的核心功能。
//
// 节点是 EdgeVPN 网络的基本单元，负责：
//   - 管理 libp2p 主机
//   - 协调消息传递
//   - 维护区块链账本
//   - 处理网络服务
//
// 基本用法：
//
//   node, err := node.New(
//       node.WithConfig(config),
//       node.WithLogger(logger),
//   )
//   if err != nil {
//       log.Fatal(err)
//   }
//   err = node.Start(ctx)
//
package node
```

#### 5.1.2 函数文档

导出函数应该有完整的文档，包括功能描述、参数说明和返回值说明。

```go
// New 创建新的节点实例
//
// 参数：
//   p - 可选的配置选项，如 WithConfig、WithLogger 等
//
// 返回：
//   *Node - 新创建的节点实例
//   error - 创建节点时可能出现的错误
//
// 示例：
//
//   node, err := node.New(
//       node.WithConfig(config),
//       node.WithLogger(logger),
//   )
//   if err != nil {
//       log.Fatal(err)
//   }
func New(p ...Option) (*Node, error) {
    // ...
}
```

#### 5.1.3 类型文档

导出类型应该有文档，说明类型的用途和使用方法。

```go
// Node 节点结构体，表示 EdgeVPN 网络中的一个节点
//
// 节点包含以下核心组件：
//   - libp2p 主机：提供 P2P 网络通信能力
//   - 消息中心：管理 PubSub 消息传递
//   - 区块链账本：维护分布式账本状态
//   - 连接门控器：控制对等节点的连接
//
// 节点是线程安全的，可以安全地在多个 goroutine 中使用。
type Node struct {
    // config 节点配置
    config Config

    // MessageHub 消息中心
    MessageHub *hub.MessageHub

    // host libp2p 主机
    host host.Host

    // ledger 区块链账本
    ledger *blockchain.Ledger
}
```

### 5.2 项目文档

#### 5.2.1 README 文档

README 文档应该包含：

- 项目简介
- 主要功能
- 安装说明
- 使用示例
- 配置说明
- 常见问题

#### 5.2.2 API 文档

API 文档应该包含：

- 接口列表
- 请求参数
- 响应格式
- 错误码
- 使用示例

#### 5.2.3 架构文档

架构文档应该包含：

- 系统架构图
- 模块说明
- 数据流程
- 技术选型

### 5.3 注释规范

#### 5.3.1 注释原则

- 注释应该解释"为什么"，而不是"是什么"
- 注释应该准确、简洁、清晰
- 避免无用的注释

```go
// 好的注释
// 使用 SHA256 而不是 MD5，因为 SHA256 更安全
hash := sha256.Sum256(data)

// 不好的注释
// 计算哈希
hash := sha256.Sum256(data)
```

#### 5.3.2 注释位置

- 包注释放在 package 声明之前
- 类型注释放在类型声明之前
- 函数注释放在函数声明之前
- 复杂逻辑注释放在逻辑之前

## 6. Git 提交规范

### 6.1 提交信息格式

使用约定式提交（Conventional Commits）格式：

```
<type>(<scope>): <subject>

<body>

<footer>
```

### 6.2 类型（type）

- `feat`：新功能
- `fix`：修复 bug
- `docs`：文档更新
- `style`：代码格式（不影响代码运行的变动）
- `refactor`：重构（既不是新增功能，也不是修改 bug 的代码变动）
- `perf`：性能优化
- `test`：增加测试
- `chore`：构建过程或辅助工具的变动

### 6.3 范围（scope）

范围指明提交影响的模块或功能：

- `node`：节点模块
- `blockchain`：区块链模块
- `services`：服务模块
- `api`：API 模块
- `docs`：文档

### 6.4 示例

```bash
# 新功能
feat(node): add support for IPv6 addresses

# 修复 bug
fix(blockchain): resolve race condition in ledger sync

# 文档更新
docs(api): update API documentation for v2.0

# 重构
refactor(services): simplify service registration logic

# 性能优化
perf(vpn): reduce memory allocation in packet forwarding
```

## 7. 测试规范

### 7.1 单元测试

- 每个包都应该有测试文件
- 测试文件命名为 `*_test.go`
- 测试函数以 `Test` 开头

```go
// node_test.go
package node

import (
    "testing"
)

func TestNewNode(t *testing.T) {
    node, err := New()
    if err != nil {
        t.Fatalf("New() error = %v, want nil", err)
    }
    if node == nil {
        t.Fatal("New() node = nil, want non-nil")
    }
}
```

### 7.2 集成测试

- 测试多个模块的交互
- 使用真实的依赖
- 测试文件命名为 `*_integration_test.go`

### 7.3 测试覆盖率

- 目标覆盖率：80% 以上
- 核心模块：90% 以上
- 使用 `go test -cover` 检查覆盖率

## 8. 性能规范

### 8.1 内存管理

- 避免不必要的内存分配
- 使用对象池复用对象
- 及时释放资源

```go
// 好的做法
var bufPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func processData() {
    buf := bufPool.Get().([]byte)
    defer bufPool.Put(buf)
    // 使用 buf
}

// 不好的做法
func processData() {
    buf := make([]byte, 1024)
    // 使用 buf
}
```

### 8.2 并发性能

- 合理使用 goroutine
- 避免过多的 goroutine
- 使用工作池模式

```go
// 好的做法
type WorkerPool struct {
    tasks chan Task
    workers int
}

func NewWorkerPool(workers int) *WorkerPool {
    pool := &WorkerPool{
        tasks:   make(chan Task, 100),
        workers: workers,
    }
    for i := 0; i < workers; i++ {
        go pool.worker()
    }
    return pool
}

// 不好的做法
func processTasks(tasks []Task) {
    for _, task := range tasks {
        go func(t Task) {
            process(t)
        }(task)
    }
}
```

## 9. 安全规范

### 9.1 输入验证

- 验证所有外部输入
- 使用白名单而不是黑名单
- 限制输入长度

```go
// 好的做法
func validateInput(input string) error {
    if len(input) > 100 {
        return errors.New("input too long")
    }
    if !isValidInput(input) {
        return errors.New("invalid input")
    }
    return nil
}

// 不好的做法
func validateInput(input string) error {
    if !isInvalidInput(input) {
        return nil
    }
    return errors.New("invalid input")
}
```

### 9.2 敏感数据

- 不在日志中记录敏感数据
- 不在错误消息中暴露内部信息
- 使用环境变量管理密钥

```go
// 好的做法
log.Infof("Connecting to peer %s", peerID)

// 不好的做法
log.Infof("Connecting to peer %s with token %s", peerID, token)
```

## 10. 工具和配置

### 10.1 代码格式化工具

- `gofmt`：Go 代码格式化
- `goimports`：导入管理
- `golint`：代码风格检查
- `staticcheck`：静态分析

### 10.2 IDE 配置

推荐使用 VSCode 或 GoLand，并配置：

- 自动格式化
- 自动导入
- 代码检查
- 测试运行

### 10.3 Pre-commit 钩子

使用 pre-commit 钩子确保代码质量：

```bash
#!/bin/sh
# .git/hooks/pre-commit

# 格式化代码
gofmt -w .
goimports -w .

# 运行测试
go test ./...

# 运行 linter
golangci-lint run
```

## 11. 总结

遵循本开发规范有助于保持代码质量、提高开发效率并促进团队协作。所有开发者都应该熟悉并遵守这些规范。规范会根据项目发展不断更新和完善。
