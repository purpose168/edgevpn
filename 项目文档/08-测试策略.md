# EdgeVPN 测试策略

## 1. 概述

本文档定义了 EdgeVPN 项目的测试策略，包括单元测试、集成测试、系统测试的实施方法及测试工具使用规范。测试是确保代码质量、发现潜在问题和验证功能正确性的重要手段。

## 2. 测试层次

### 2.1 测试金字塔

```
        /\
       /  \
      / E2E \
     /--------\
    / 集成测试 \
   /------------\
  /   单元测试    \
 /------------------\
```

### 2.2 测试类型

| 测试类型 | 目标 | 覆盖范围 | 执行频率 |
|---------|------|----------|----------|
| 单元测试 | 函数和方法 | 代码行 | 每次提交 |
| 集成测试 | 模块交互 | 功能点 | 每次 PR |
| 系统测试 | 端到端流程 | 用户场景 | 每次发布 |
| E2E 测试 | 完整用户流程 | 业务流程 | 每次发布 |

## 3. 单元测试

### 3.1 测试框架

EdgeVPN 使用 Ginkgo + Gomega 作为 BDD 测试框架。

#### 3.1.1 安装

```bash
# 安装 Ginkgo
go install github.com/onsi/ginkgo/v2/ginkgo@latest

# 安装 Gomega
go install github.com/onsi/gomega@latest
```

#### 3.1.2 测试文件结构

```
pkg/
├── node/
│   ├── node.go
│   ├── node_suite_test.go
│   └── node_test.go
├── blockchain/
│   ├── block.go
│   ├── blockchain_suite_test.go
│   └── block_test.go
```

### 3.2 测试编写规范

#### 3.2.1 测试套件

每个包都应该有测试套件文件 `*_suite_test.go`：

```go
package node

import (
    "testing"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
)

func TestNode(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "Node Suite")}
```

#### 3.2.2 测试用例

测试用例应该遵循 BDD 风格：

```go
package node

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
)

var _ = Describe("Node", func() {
    var (
        node *Node
        err  error
    )

    BeforeEach(func() {
        // 每个测试前的准备
        node, err = New()
        Expect(err).ToNot(HaveOccurred())
    })

    AfterEach(func() {
        // 每个测试后的清理
        if node != nil {
            node.Close()
        }
    })

    Context("创建新节点", func() {
        It("应该成功创建节点", func() {
            Expect(node).ToNot(BeNil())
        })

        It("应该初始化配置", func() {
            Expect(node.config).ToNot(BeZero())
        })
    })

    Context("节点启动", func() {
        It("应该成功启动节点", func() {
            ctx := context.Background()
            err := node.Start(ctx)
            Expect(err).ToNot(HaveOccurred())
        })

        It("应该创建 libp2p 主机", func() {
            Expect(node.host).ToNot(BeNil())
        })
    })
})
```

### 3.3 测试覆盖率

#### 3.3.1 覆盖率目标

| 模块类型 | 目标覆盖率 |
|---------|-----------|
| 核心模块 | 90% 以上 |
| 服务模块 | 85% 以上 |
| 工具模块 | 80% 以上 |
| 整体项目 | 80% 以上 |

#### 3.3.2 生成覆盖率报告

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out ./...

# 查看覆盖率
go tool cover -html=coverage.out

# 查看覆盖率百分比
go tool cover -func=coverage.out
```

#### 3.3.3 CI/CD 集成

在 GitHub Actions 中添加覆盖率检查：

```yaml
- name: Run tests with coverage
  run: |
    go test -coverprofile=coverage.out -covermode=atomic ./...

- name: Upload coverage to Codecov
  uses: codecov/codecov-action@v3
  with:
    files: ./coverage.out
```

### 3.4 Mock 和 Stub

#### 3.4.1 使用 Mock

对于外部依赖，使用 Mock 进行测试：

```go
package node_test

import (
    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
    "github.com/purpose168/edgevpn/pkg/blockchain"
)

type MockLedger struct {
    mock.Mock
}

func (m *MockLedger) Add(key string, value interface{}) error {
    args := m.Called(key, value)
    return args.Error(0)
}

var _ = Describe("Node", func() {
    var (
        node   *Node
        ledger *MockLedger
    )

    BeforeEach(func() {
        ledger = &MockLedger{}
        node, _ = New(WithLedger(ledger))
    })

    It("应该调用 ledger.Add", func() {
        ledger.On("Add", "test", "value").Return(nil)

        node.AddToLedger("test", "value")

        ledger.AssertExpectations(GinkgoT())
    })
})
```

#### 3.4.2 使用测试替身

对于简单的依赖，使用测试替身：

```go
package services_test

type TestStore struct {
    data map[string][]byte
    mu   sync.Mutex
}

func (s *TestStore) Get(key string) ([]byte, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    return s.data[key], nil
}

func (s *TestStore) Set(key string, value []byte) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.data[key] = value
    return nil
}
```

## 4. 集成测试

### 4.1 测试目标

集成测试验证多个模块之间的交互是否正确。

### 4.2 测试环境

#### 4.2.1 本地测试环境

```bash
# 创建测试网络
docker network create edgevpn-test

# 启动测试节点
docker run -d --name node1 --network edgevpn-test \
    -e EDGEVPNTOKEN=test_token \
    edgevpn:latest

docker run -d --name node2 --network edgevpn-test \
    -e EDGEVPNTOKEN=test_token \
    edgevpn:latest
```

#### 4.2.2 测试配置

创建 `tests/integration/config.yaml`：

```yaml
network:
  token: "test_token"
  address: "10.10.0.1/24"

api:
  enabled: true
  listen: "127.0.0.1:18080"

dhcp:
  enabled: false
```

### 4.3 测试用例

#### 4.3.1 节点发现测试

```go
package integration

import (
    "context"
    "time"

    . "github.com/onsi/ginkgo/v2"
    . "github.com/onsi/gomega"
    "github.com/purpose168/edgevpn/pkg/node"
)

var _ = Describe("节点发现集成测试", func() {
    var (
        node1, node2 *node.Node
    )

    BeforeEach(func() {
        var err error
        node1, err = node.New(
            node.WithToken("test_token"),
            node.WithAddress("10.10.0.1/24"),
        )
        Expect(err).ToNot(HaveOccurred())

        node2, err = node.New(
            node.WithToken("test_token"),
            node.WithAddress("10.10.0.2/24"),
        )
        Expect(err).ToNot(HaveOccurred())
    })

    AfterEach(func() {
        node1.Close()
        node2.Close()
    })

    It("节点应该能够相互发现", func() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // 启动节点
        go node1.Start(ctx)
        go node2.Start(ctx)

        // 等待发现
        time.Sleep(10 * time.Second)

        // 验证连接
        peers := node1.Host().Network().Peers()
        Expect(peers).To(ContainElement(node2.Host().ID()))
    })
})
```

#### 4.3.2 区块链同步测试

```go
var _ = Describe("区块链同步集成测试", func() {
    It("节点应该能够同步区块链", func() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // 启动节点
        go node1.Start(ctx)
        go node2.Start(ctx)

        // 等待同步
        time.Sleep(10 * time.Second)

        // 获取账本
        ledger1, _ := node1.Ledger()
        ledger2, _ := node2.Ledger()

        // 验证同步
        Expect(ledger1.Height()).To(Equal(ledger2.Height()))
    })
})
```

## 5. 系统测试

### 5.1 测试目标

系统测试验证完整的用户场景和端到端流程。

### 5.2 测试场景

#### 5.2.1 VPN 连接测试

```bash
#!/bin/bash

# VPN 连接测试脚本

# 1. 启动节点
docker-compose -f tests/docker-compose.yml up -d

# 2. 等待节点就绪
sleep 30

# 3. 测试 VPN 连接
docker exec node1 ping -c 5 10.10.0.2

# 4. 验证结果
if [ $? -eq 0 ]; then
    echo "VPN 连接测试通过"
else
    echo "VPN 连接测试失败"
    exit 1
fi

# 5. 清理
docker-compose -f tests/docker-compose.yml down
```

#### 5.2.2 DNS 解析测试

```bash
#!/bin/bash

# DNS 解析测试脚本

# 1. 启动节点
docker-compose -f tests/docker-compose.yml up -d

# 2. 等待节点就绪
sleep 30

# 3. 添加 DNS 记录
curl -X POST http://localhost:8080/api/dns \
    -H "Content-Type: application/json" \
    -d '{
        "name": "test.local",
        "type": "A",
        "value": "10.10.0.1"
    }'

# 4. 测试 DNS 解析
dig @localhost -p 53 test.local

# 5. 验证结果
if dig @localhost -p 53 test.local +short | grep -q "10.10.0.1"; then
    echo "DNS 解析测试通过"
else
    echo "DNS 解析测试失败"
    exit 1
fi

# 6. 清理
docker-compose -f tests/docker-compose.yml down
```

#### 5.2.3 文件传输测试

```bash
#!/bin/bash

# 文件传输测试脚本

# 1. 启动节点
docker-compose -f tests/docker-compose.yml up -d

# 2. 等待节点就绪
sleep 30

# 3. 在节点1上创建测试文件
docker exec node1 sh -c "echo 'test content' > /tmp/test.txt"

# 4. 共享文件
docker exec node1 edgevpn file share /tmp/test.txt test-file

# 5. 在节点2上接收文件
docker exec node2 edgevpn file receive test-file /tmp/received.txt

# 6. 验证文件内容
CONTENT=$(docker exec node2 cat /tmp/received.txt)
if [ "$CONTENT" = "test content" ]; then
    echo "文件传输测试通过"
else
    echo "文件传输测试失败"
    exit 1
fi

# 7. 清理
docker-compose -f tests/docker-compose.yml down
```

## 6. 性能测试

### 6.1 基准测试

#### 6.1.1 编写基准测试

```go
package node

import (
    "testing"
)

func BenchmarkNodeNew(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _, _ = New()
    }
}

func BenchmarkPacketForwarding(b *testing.B) {
    node, _ := New()
    defer node.Close()

    packet := make([]byte, 1024)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        node.forwardPacket(packet)
    }
}
```

#### 6.1.2 运行基准测试

```bash
# 运行所有基准测试
go test -bench=. -benchmem

# 运行特定基准测试
go test -bench=BenchmarkNodeNew -benchmem

# 运行基准测试并生成 CPU profile
go test -bench=. -cpuprofile=cpu.prof

# 分析 profile
go tool pprof cpu.prof
```

### 6.2 压力测试

#### 6.2.1 连接压力测试

```bash
#!/bin/bash

# 连接压力测试脚本

# 1. 启动节点
docker-compose -f tests/docker-compose.yml up -d

# 2. 等待节点就绪
sleep 30

# 3. 创建多个客户端
for i in {1..100}; do
    docker run -d --name client${i} --network edgevpn-test \
        -e EDGEVPNTOKEN=test_token \
        edgevpn:latest &
done

# 4. 等待连接建立
sleep 60

# 5. 检查连接数
CONNECTIONS=$(curl -s http://localhost:8080/api/summary | jq '.data.total_peers')
echo "当前连接数: $CONNECTIONS"

# 6. 清理
docker-compose -f tests/docker-compose.yml down
for i in {1..100}; do
    docker rm -f client${i}
done
```

#### 6.2.2 数据包压力测试

```bash
#!/bin/bash

# 数据包压力测试脚本

# 1. 启动节点
docker-compose -f tests/docker-compose.yml up -d

# 2. 等待节点就绪
sleep 30

# 3. 发送大量数据包
for i in {1..10000}; do
    ping -c 1 10.10.0.2 &
done

# 4. 等待完成
wait

# 5. 检查性能指标
curl -s http://localhost:8080/api/metrics

# 6. 清理
docker-compose -f tests/docker-compose.yml down
```

## 7. 测试工具

### 7.1 单元测试工具

| 工具 | 用途 |
|------|------|
| go test | Go 内置测试工具 |
| ginkgo | BDD 测试框架 |
| gomega | 匹配器库 |
| mock | Mock 生成工具 |

### 7.2 集成测试工具

| 工具 | 用途 |
|------|------|
| docker | 容器化测试环境 |
| docker-compose | 多容器编排 |
| curl | API 测试 |
| dig | DNS 测试 |

### 7.3 性能测试工具

| 工具 | 用途 |
|------|------|
| go test -bench | 基准测试 |
| pprof | 性能分析 |
| wrk | HTTP 压力测试 |
| iperf3 | 网络性能测试 |

### 7.4 覆盖率工具

| 工具 | 用途 |
|------|------|
| go tool cover | 覆盖率分析 |
| codecov | 覆盖率报告 |
| coveralls | 覆盖率报告 |

## 8. CI/CD 集成

### 8.1 GitHub Actions 配置

#### 8.1.1 测试工作流

`.github/workflows/test.yml`：

```yaml
name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: ['1.24', '1.25']

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Install dependencies
        run: |
          go mod download
          go install github.com/onsi/ginkgo/v2/ginkgo@latest

      - name: Run tests
        run: |
          ginkgo -r --randomize-all --randomize-suites --fail-on-pending --cover --trace --race --progress

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out
```

### 8.2 测试报告

#### 8.2.1 生成测试报告

```bash
# 生成 HTML 测试报告
ginkgo -r --output-dir=reports

# 查看报告
open reports/report.html
```

#### 8.2.2 覆盖率报告

```bash
# 生成覆盖率报告
go test -coverprofile=coverage.out -covermode=atomic ./...

# 生成 HTML 报告
go tool cover -html=coverage.out -o coverage.html

# 查看报告
open coverage.html
```

## 9. 测试最佳实践

### 9.1 测试命名

- 使用描述性的测试名称
- 遵循"应该..."的格式
- 包含测试的场景

```go
// 好的测试命名
It("应该成功创建节点", func() {})
It("应该在节点启动后创建 libp2p 主机", func() {})
It("应该在网络分区后重新连接", func() {})

// 不好的测试命名
It("测试节点创建", func() {})
It("测试主机创建", func() {})
It("测试重新连接", func() {})
```

### 9.2 测试隔离

- 每个测试应该独立
- 不依赖测试执行顺序
- 使用 BeforeEach 和 AfterEach 清理

```go
var _ = Describe("测试隔离", func() {
    var node *Node

    BeforeEach(func() {
        // 每个测试前创建新节点
        node, _ = New()
    })

    AfterEach(func() {
        // 每个测试后清理节点
        if node != nil {
            node.Close()
        }
    })

    It("测试1", func() {
        // 测试逻辑
    })

    It("测试2", func() {
        // 测试逻辑，不依赖测试1
    })
})
```

### 9.3 测试数据

- 使用固定的测试数据
- 避免随机数据（除非测试随机性）
- 提供测试数据集

```go
// 好的做法
var testData = []struct {
    input    string
    expected string
}{
    {"test", "test"},
    {"hello", "hello"},
    {"world", "world"},
}

for _, tc := range testData {
    It(fmt.Sprintf("应该处理输入 %s", tc.input), func() {
        result := process(tc.input)
        Expect(result).To(Equal(tc.expected))
    })
}

// 不好的做法
It("应该处理随机输入", func() {
    input := generateRandomString()
    result := process(input)
    Expect(result).ToNot(BeEmpty())
})
```

### 9.4 断言使用

- 使用有意义的断言
- 提供清晰的错误消息
- 避免过多的断言

```go
// 好的做法
Expect(node).ToNot(BeNil(), "节点应该被创建")
Expect(err).ToNot(HaveOccurred(), "不应该有错误")
Expect(result).To(Equal(expected), "结果应该匹配预期值")

// 不好的做法
Expect(node).ToNot(BeNil())
Expect(err).ToNot(HaveOccurred())
Expect(result).To(Equal(expected))
```

## 10. 测试维护

### 10.1 测试更新

- 代码变更时更新测试
- 删除过时的测试
- 添加新功能的测试

### 10.2 测试审查

- 代码审查时审查测试
- 确保测试覆盖率
- 验证测试质量

### 10.3 测试文档

- 为复杂测试添加注释
- 说明测试的目的
- 记录已知的限制

## 11. 总结

遵循本测试策略有助于确保 EdgeVPN 的代码质量和功能正确性。测试应该贯穿开发的整个生命周期，从单元测试到集成测试，再到系统测试，全面覆盖代码的各个方面。
