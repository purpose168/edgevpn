# EdgeVPN æ•°æ®æµç¨‹

## 1. æ¦‚è¿°

EdgeVPN çš„æ•°æ®æµç¨‹æ¶‰åŠå¤šä¸ªæ¨¡å—ä¹‹é—´çš„åä½œï¼ŒåŒ…æ‹¬èŠ‚ç‚¹å¯åŠ¨ã€æ•°æ®åŒæ­¥ã€VPN æ•°æ®åŒ…è½¬å‘ã€æœåŠ¡å‘ç°ç­‰å…³é”®ä¸šåŠ¡æµç¨‹ã€‚æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜è¿™äº›å…³é”®ä¸šåŠ¡æµç¨‹çš„æ•°æ®æµè½¬è¿‡ç¨‹ã€‚

## 2. èŠ‚ç‚¹å¯åŠ¨æµç¨‹

### 2.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph STARTUP["ğŸš€ èŠ‚ç‚¹å¯åŠ¨æµç¨‹"]
        direction TB
        A["1ï¸âƒ£ ç”¨æˆ·æ‰§è¡Œå‘½ä»¤<br/>User Execute Command"]
        B["2ï¸âƒ£ cmd/main.go<br/>è§£æå‘½ä»¤è¡Œå‚æ•°"]
        C["3ï¸âƒ£ åŠ è½½é…ç½®æ–‡ä»¶æˆ–ä»¤ç‰Œ<br/>Load Config/Token"]
        D["4ï¸âƒ£ pkg/config/config.go<br/>è§£æé…ç½®"]
        E["5ï¸âƒ£ pkg/node/node.go<br/>åˆ›å»ºèŠ‚ç‚¹å®ä¾‹"]
        F["6ï¸âƒ£ åˆ›å»º libp2p ä¸»æœº<br/>Create libp2p Host"]
        G["7ï¸âƒ£ pkg/discovery/dht.go<br/>åˆå§‹åŒ– DHT å‘ç°"]
        H["8ï¸âƒ£ pkg/hub/hub.go<br/>åŠ å…¥ GossipSub ä¸»é¢˜"]
        I["9ï¸âƒ£ pkg/blockchain/ledger.go<br/>åŒæ­¥åŒºå—é“¾è´¦æœ¬"]
        J["ğŸ”Ÿ pkg/services/<br/>å¯åŠ¨ç½‘ç»œæœåŠ¡"]
        K["1ï¸âƒ£1ï¸âƒ£ api/api.go<br/>å¯åŠ¨ REST APIï¼ˆå¯é€‰ï¼‰"]
        L["âœ… èŠ‚ç‚¹å°±ç»ª<br/>Node Ready"]
    end

    subgraph SERVICES["âš™ï¸ ç½‘ç»œæœåŠ¡"]
        direction LR
        VPN["ğŸ” VPN æœåŠ¡"]
        DNS["ğŸŒ DNS æœåŠ¡"]
        FILE["ğŸ“ æ–‡ä»¶æœåŠ¡"]
        PROXY["ğŸ”„ ä»£ç†æœåŠ¡"]
    end

    A -->|"å‘½ä»¤è¡Œ"| B
    B -->|"å‚æ•°è§£æ"| C
    C -->|"æ–‡ä»¶è¯»å–"| D
    D -->|"é…ç½®æ³¨å…¥"| E
    E -->|"èŠ‚ç‚¹åˆå§‹åŒ–"| F
    F -->|"P2P ä¸»æœº"| G
    G -->|"èŠ‚ç‚¹å‘ç°"| H
    H -->|"æ¶ˆæ¯è®¢é˜…"| I
    I -->|"è´¦æœ¬åŒæ­¥"| J
    J -->|"æœåŠ¡å¯åŠ¨"| K
    K -->|"API å°±ç»ª"| L

    J --> VPN
    J --> DNS
    J --> FILE
    J --> PROXY

    %% æ ·å¼å®šä¹‰
    classDef stepStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef serviceStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef finalStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20

    class A,B,C,D,E,F,G,H,I,J,K stepStyle
    class VPN,DNS,FILE,PROXY serviceStyle
    class L finalStyle
```

### 2.2 è¯¦ç»†è¯´æ˜

#### æ­¥éª¤ 1-3ï¼šå‘½ä»¤è§£æå’Œé…ç½®åŠ è½½

```go
// cmd/main.go
func main() {
    app := &cli.App{
        Name:    "edgevpn",
        Version: internal.Version,
        Flags:   cmd.MainFlags(),
        Commands: []*cli.Command{
            cmd.Start(),
            cmd.API(),
            // ...
        },
        Action: cmd.Main(),
    }
    app.Run(os.Args)
}
```

**æ•°æ®æµè½¬**ï¼š
- å‘½ä»¤è¡Œå‚æ•° â†’ CLI è§£æå™¨
- é…ç½®æ–‡ä»¶/ä»¤ç‰Œ â†’ é…ç½®è§£æå™¨
- ç¯å¢ƒå˜é‡ â†’ é…ç½®åˆå¹¶

#### æ­¥éª¤ 4-6ï¼šèŠ‚ç‚¹åˆ›å»º

```go
// pkg/node/node.go
func New(p ...Option) (*Node, error) {
    c := &Config{
        DiscoveryInterval: 5 * time.Minute,
        StreamHandlers:    make(map[protocol.Protocol]StreamHandler),
        LedgerAnnounceTime: 5 * time.Second,
        // ...
    }
    c.Apply(p...)
    return &Node{config: *c}, nil
}
```

**æ•°æ®æµè½¬**ï¼š
- é…ç½®é€‰é¡¹ â†’ èŠ‚ç‚¹é…ç½®
- èŠ‚ç‚¹é…ç½® â†’ libp2p ä¸»æœºé€‰é¡¹
- libp2p é€‰é¡¹ â†’ libp2p ä¸»æœºå®ä¾‹

#### æ­¥éª¤ 7-9ï¼šç½‘ç»œåˆå§‹åŒ–

```go
// pkg/discovery/dht.go
func (d *DHT) startDHT(ctx context.Context, h host.Host) (*dht.IpfsDHT, error) {
    kad, err := dht.New(ctx, h, d.dhtOptions...)
    if err != nil {
        return d.IpfsDHT, err
    }
    d.IpfsDHT = kad
    return d.IpfsDHT, nil
}
```

**æ•°æ®æµè½¬**ï¼š
- OTP å¯†é’¥ â†’ ä¼šåˆç‚¹å­—ç¬¦ä¸²
- ä¼šåˆç‚¹å­—ç¬¦ä¸² â†’ DHT ä¸»é¢˜
- DHT ä¸»é¢˜ â†’ èŠ‚ç‚¹å‘ç°

#### æ­¥éª¤ 10-12ï¼šæœåŠ¡å¯åŠ¨

```go
// pkg/services/services.go
func VPNNetworkService(p ...Option) node.NetworkService {
    return func(ctx context.Context, nc node.Config, n *node.Node, b *blockchain.Ledger) error {
        // åˆ›å»º VPN æ¥å£
        ifce, err := createInterface(c)
        // è®¾ç½®æµå¤„ç†å™¨
        n.Host().SetStreamHandler(protocol.EdgeVPN.ID(), streamHandler(b, ifce, c, nc))
        // å…¬å‘Š IP åœ°å€
        b.Announce(ctx, announcetime, func() {
            // å…¬å‘Šé€»è¾‘
        })
        return nil
    }
}
```

**æ•°æ®æµè½¬**ï¼š
- æœåŠ¡é…ç½® â†’ ç½‘ç»œæœåŠ¡
- ç½‘ç»œæœåŠ¡ â†’ æµå¤„ç†å™¨
- æµå¤„ç†å™¨ â†’ libp2p ä¸»æœº

## 3. åŒºå—é“¾åŒæ­¥æµç¨‹

### 3.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph NODE_A["ğŸ–¥ï¸ èŠ‚ç‚¹ Aï¼ˆå‘é€æ–¹ï¼‰"]
        direction TB
        A1["1ï¸âƒ£ åˆ›å»ºæ–°åŒºå—<br/>Create New Block"]
        A2["2ï¸âƒ£ è®¡ç®—åŒºå—å“ˆå¸Œ<br/>Calculate Block Hash"]
        A3["3ï¸âƒ£ PubSub å¹¿æ’­åŒºå—<br/>Broadcast via PubSub"]
    end

    subgraph NODE_B["ğŸ–¥ï¸ èŠ‚ç‚¹ Bï¼ˆæ¥æ”¶æ–¹ï¼‰"]
        direction TB
        B1["4ï¸âƒ£ æ¥æ”¶åŒºå—æ¶ˆæ¯<br/>Receive Block Message"]
        B2{"5ï¸âƒ£ éªŒè¯åŒºå—<br/>Verify Block"}
        B3["âœ… æ·»åŠ åˆ°æœ¬åœ°åŒºå—é“¾<br/>Add to Local Chain"]
        B4["âŒ ä¸¢å¼ƒåŒºå—<br/>Discard Block"]
        B5["6ï¸âƒ£ æ›´æ–°æœ¬åœ°è´¦æœ¬æ•°æ®<br/>Update Local Ledger"]
        B6["âœ… è´¦æœ¬åŒæ­¥å®Œæˆ<br/>Sync Complete"]
    end

    subgraph VERIFY["ğŸ” éªŒè¯æ£€æŸ¥"]
        direction LR
        V1["æ£€æŸ¥ç´¢å¼•è¿ç»­æ€§"]
        V2["æ£€æŸ¥å‰ä¸€åŒºå—å“ˆå¸Œ"]
        V3["æ£€æŸ¥å½“å‰åŒºå—å“ˆå¸Œ"]
    end

    A1 -->|"åŒºå—æ„å»º"| A2
    A2 -->|"å“ˆå¸Œè®¡ç®—"| A3
    A3 -->|"GossipSub"| B1
    B1 -->|"åŒºå—æ•°æ®"| B2
    B2 -->|"éªŒè¯é€šè¿‡"| B3
    B2 -->|"éªŒè¯å¤±è´¥"| B4
    B3 -->|"é“¾æ›´æ–°"| B5
    B5 -->|"æ•°æ®åŒæ­¥"| B6

    B2 -.->|"æ£€æŸ¥é¡¹"| V1
    B2 -.->|"æ£€æŸ¥é¡¹"| V2
    B2 -.->|"æ£€æŸ¥é¡¹"| V3

    %% æ ·å¼å®šä¹‰
    classDef nodeAStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef nodeBStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef verifyStyle fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px,color:#4A148C
    classDef successStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20
    classDef failStyle fill:#FFEBEE,stroke:#C62828,stroke-width:2px,color:#B71C1C

    class A1,A2,A3 nodeAStyle
    class B1,B5 nodeBStyle
    class B2 verifyStyle
    class B3,B6 successStyle
    class B4 failStyle
    class V1,V2,V3 verifyStyle
```

### 3.2 è¯¦ç»†è¯´æ˜

#### æ­¥éª¤ 1-3ï¼šåŒºå—åˆ›å»ºå’Œå¹¿æ’­

```go
// pkg/blockchain/block.go
func (oldBlock Block) NewBlock(s map[string]map[string]Data) Block {
    var newBlock Block
    t := time.Now().UTC()
    newBlock.Index = oldBlock.Index + 1
    newBlock.Timestamp = t.String()
    newBlock.Storage = s
    newBlock.PrevHash = oldBlock.Hash
    newBlock.Hash = newBlock.Checksum()
    return newBlock
}
```

**æ•°æ®æµè½¬**ï¼š
- å­˜å‚¨æ•°æ® â†’ åŒºå—æ•°æ®
- åŒºå—æ•°æ® â†’ SHA256 å“ˆå¸Œ
- åŒºå— â†’ PubSub æ¶ˆæ¯

#### æ­¥éª¤ 4-6ï¼šåŒºå—æ¥æ”¶å’ŒéªŒè¯

```go
// pkg/blockchain/ledger.go
func (l *Ledger) ReceiveMessage(m *hub.Message, c chan *hub.Message) error {
    var block Block
    json.Unmarshal(m.Payload, &block)

    // éªŒè¯åŒºå—
    if !block.IsValid(l.blockchain[len(l.blockchain)-1]) {
        return errors.New("Invalid block")
    }

    // æ·»åŠ åˆ°åŒºå—é“¾
    l.blockchain = append(l.blockchain, block)

    // æ›´æ–°å­˜å‚¨
    for k, v := range block.Storage {
        l.store[k] = v
    }

    return nil
}
```

**æ•°æ®æµè½¬**ï¼š
- PubSub æ¶ˆæ¯ â†’ åŒºå—å¯¹è±¡
- åŒºå—å¯¹è±¡ â†’ éªŒè¯é€»è¾‘
- éªŒè¯ç»“æœ â†’ åŒºå—é“¾/å­˜å‚¨

## 4. VPN æ•°æ®åŒ…è½¬å‘æµç¨‹

### 4.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph SOURCE["ğŸ–¥ï¸ æºèŠ‚ç‚¹"]
        direction TB
        A["1ï¸âƒ£ åº”ç”¨å‘é€æ•°æ®åŒ…<br/>App Sends Packet"]
        B["2ï¸âƒ£ pkg/vpn/interface.go<br/>æ•è·æ•°æ®åŒ…"]
        C["3ï¸âƒ£ è§£ææ•°æ®åŒ…<br/>Parse Packet"]
        D["4ï¸âƒ£ æå–ç›®æ ‡ IP<br/>Extract Dest IP"]
        E["5ï¸âƒ£ æŸ¥è¯¢è´¦æœ¬è·å– PeerID<br/>Query Ledger for PeerID"]
        F["6ï¸âƒ£ æŸ¥æ‰¾/åˆ›å»º P2P æµ<br/>Find/Create P2P Stream"]
        G["7ï¸âƒ£ è½¬å‘æ•°æ®åŒ…<br/>Forward Packet"]
    end

    subgraph TARGET["ğŸ–¥ï¸ ç›®æ ‡èŠ‚ç‚¹"]
        direction TB
        H["8ï¸âƒ£ æ¥æ”¶æ•°æ®åŒ…<br/>Receive Packet"]
        I["9ï¸âƒ£ å†™å…¥ VPN æ¥å£<br/>Write to VPN Interface"]
        J["âœ… æ•°æ®åŒ…åˆ°è¾¾ç›®æ ‡åº”ç”¨<br/>Packet Arrives at App"]
    end

    subgraph PROTOCOL["ğŸ“¦ åè®®å±‚"]
        direction LR
        P1["ä»¥å¤ªç½‘"]
        P2["IP"]
        P3["UDP"]
        P4["TCP"]
    end

    A -->|"TUN/TAP"| B
    B -->|"åŸå§‹æ•°æ®"| C
    C -->|"è§£æç»“æœ"| D
    D -->|"IP åœ°å€"| E
    E -->|"PeerID"| F
    F -->|"libp2p æµ"| G
    G -->|"åŠ å¯†ä¼ è¾“"| H
    H -->|"è§£å¯†æ•°æ®"| I
    I -->|"è™šæ‹Ÿæ¥å£"| J

    C -.->|"åè®®ç±»å‹"| P1
    C -.->|"åè®®ç±»å‹"| P2
    C -.->|"åè®®ç±»å‹"| P3
    C -.->|"åè®®ç±»å‹"| P4

    %% æ ·å¼å®šä¹‰
    classDef sourceStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef targetStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef protocolStyle fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px,color:#4A148C
    classDef finalStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20

    class A,B,C,D,E,F,G sourceStyle
    class H,I targetStyle
    class J finalStyle
    class P1,P2,P3,P4 protocolStyle
```

### 4.2 è¯¦ç»†è¯´æ˜

#### æ­¥éª¤ 1-4ï¼šæ•°æ®åŒ…æ•è·å’Œè§£æ

```go
// pkg/vpn/vpn.go
func streamHandler(b *blockchain.Ledger, ifce *water.Interface, c *Config, nc node.Config) func(stream network.Stream) {
    return func(stream network.Stream) {
        // è¯»å– VPN æ¥å£æ•°æ®åŒ…
        packet := make([]byte, ifce.MTU())
        n, err := ifce.Read(packet)
        if err != nil {
            return
        }

        // è§£ææ•°æ®åŒ…
        packet = packet[:n]
        ethPacket := gopacket.NewPacket(packet, layers.LayerTypeEthernet, gopacket.Default)

        // æå– IP å±‚
        ipLayer := ethPacket.Layer(layers.LayerTypeIPv4)
        if ipLayer == nil {
            return
        }
        ip, _ := ipLayer.(*layers.IPv4)

        // è·å–ç›®æ ‡ IP
        dstIP := ip.DstIP.String()
    }
}
```

**æ•°æ®æµè½¬**ï¼š
- VPN æ¥å£ â†’ åŸå§‹æ•°æ®åŒ…
- åŸå§‹æ•°æ®åŒ… â†’ gopacket è§£æå™¨
- è§£æå™¨ â†’ IP å±‚å¯¹è±¡
- IP å±‚ â†’ ç›®æ ‡ IP åœ°å€

#### æ­¥éª¤ 5-7ï¼šèŠ‚ç‚¹æŸ¥æ‰¾å’Œè½¬å‘

```go
// pkg/vpn/vpn.go
func forwardPacket(dstIP string, b *blockchain.Ledger, n *node.Node) error {
    // æŸ¥è¯¢è´¦æœ¬è·å–ç›®æ ‡èŠ‚ç‚¹
    machines := b.CurrentData()[protocol.MachinesLedgerKey]
    var targetPeerID string
    for k, v := range machines {
        machine := &types.Machine{}
        v.Unmarshal(machine)
        if machine.IP == dstIP {
            targetPeerID = k
            break
        }
    }

    if targetPeerID == "" {
        return errors.New("Target not found")
    }

    // è·å–æˆ–åˆ›å»ºæµ
    stream, err := n.Host().NewStream(context.Background(), peer.ID(targetPeerID), protocol.EdgeVPN.ID())
    if err != nil {
        return err
    }

    // è½¬å‘æ•°æ®åŒ…
    _, err = stream.Write(packet)
    return err
}
```

**æ•°æ®æµè½¬**ï¼š
- ç›®æ ‡ IP â†’ è´¦æœ¬æŸ¥è¯¢
- è´¦æœ¬æ•°æ® â†’ PeerID
- PeerID â†’ P2P æµ
- æ•°æ®åŒ… â†’ P2P æµ

## 5. DNS æŸ¥è¯¢æµç¨‹

### 5.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph DNS_QUERY["ğŸŒ DNS æŸ¥è¯¢æµç¨‹"]
        direction TB
        A["1ï¸âƒ£ åº”ç”¨å‘é€ DNS æŸ¥è¯¢<br/>App Sends DNS Query"]
        B["2ï¸âƒ£ pkg/services/dns.go<br/>æ¥æ”¶æŸ¥è¯¢"]
        C{"3ï¸âƒ£ æ£€æŸ¥ç¼“å­˜<br/>Check Cache"}
        C1["âœ… è¿”å›ç¼“å­˜ç»“æœ<br/>Return Cached Result"]
        D["4ï¸âƒ£ æŸ¥è¯¢åŒºå—é“¾è´¦æœ¬<br/>Query Blockchain Ledger"]
        E["5ï¸âƒ£ æŸ¥æ‰¾åŒ¹é…çš„ DNS è®°å½•<br/>Find Matching DNS Record"]
        F{"6ï¸âƒ£ æ‰¾åˆ°è®°å½•ï¼Ÿ<br/>Record Found?"}
        F1["âœ… è¿”å›è®°å½•<br/>Return Record"]
        F2["ğŸ“¤ è½¬å‘åˆ°ä¸Šæ¸¸ DNS<br/>Forward to Upstream DNS"]
        G["7ï¸âƒ£ æ›´æ–°ç¼“å­˜<br/>Update Cache"]
        H["âœ… è¿”å› DNS å“åº”<br/>Return DNS Response"]
    end

    A -->|"DNS è¯·æ±‚"| B
    B -->|"æŸ¥è¯¢å¤„ç†"| C
    C -->|"ç¼“å­˜å‘½ä¸­"| C1
    C -->|"ç¼“å­˜æœªå‘½ä¸­"| D
    D -->|"è´¦æœ¬æŸ¥è¯¢"| E
    E -->|"è®°å½•æŸ¥æ‰¾"| F
    F -->|"æ‰¾åˆ°"| F1
    F -->|"æœªæ‰¾åˆ°"| F2
    F1 -->|"è®°å½•æ•°æ®"| G
    F2 -->|"ä¸Šæ¸¸å“åº”"| G
    G -->|"ç¼“å­˜æ›´æ–°"| H
    C1 -->|"å¿«é€Ÿå“åº”"| H

    %% æ ·å¼å®šä¹‰
    classDef stepStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef cacheStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef successStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20
    classDef forwardStyle fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px,color:#4A148C

    class A,B,D,E,G stepStyle
    class C cacheStyle
    class C1,F1,H successStyle
    class F,F2 forwardStyle
```

### 5.2 è¯¦ç»†è¯´æ˜

#### æ­¥éª¤ 1-4ï¼šDNS æŸ¥è¯¢æ¥æ”¶

```go
// pkg/services/dns.go
func (d dnsHandler) handleDNSRequest() func(w dns.ResponseWriter, r *dns.Msg) {
    return func(w dns.ResponseWriter, r *dns.Msg) {
        // æ£€æŸ¥ç¼“å­˜
        key := fmt.Sprintf("%s:%s", r.Question[0].Name, r.Question[0].Qtype)
        if cached, ok := d.cache.Get(key); ok {
            w.WriteMsg(cached.(*dns.Msg))
            return
        }

        // æŸ¥è¯¢åŒºå—é“¾
        response := d.parseQuery(r, false)

        // æ›´æ–°ç¼“å­˜
        d.cache.Add(key, response)

        // è¿”å›å“åº”
        w.WriteMsg(response)
    }
}
```

**æ•°æ®æµè½¬**ï¼š
- DNS æŸ¥è¯¢ â†’ DNS å¤„ç†å™¨
- DNS å¤„ç†å™¨ â†’ ç¼“å­˜æ£€æŸ¥
- ç¼“å­˜æœªå‘½ä¸­ â†’ è´¦æœ¬æŸ¥è¯¢

#### æ­¥éª¤ 5-8ï¼šè®°å½•æŸ¥æ‰¾å’Œå“åº”

```go
// pkg/services/dns.go
func (d dnsHandler) parseQuery(m *dns.Msg, forward bool) *dns.Msg {
    response := m.Copy()
    if len(m.Question) > 0 {
        q := m.Question[0]

        // ä»åŒºå—é“¾æŸ¥æ‰¾è®°å½•
        for k, v := range d.b.CurrentData()[protocol.DNSKey] {
            r, err := regexp.Compile(k)
            if err != nil {
                continue
            }
            if r.MatchString(q.Name) {
                dnsRecord := &types.DNS{}
                v.Unmarshal(dnsRecord)

                // æ„é€  DNS å“åº”
                rr, err := dns.NewRR(
                    fmt.Sprintf("%s %d IN %s %s",
                        q.Name, dnsRecord.TTL, dnsRecord.Type, dnsRecord.Value),
                )
                if err == nil {
                    response.Answer = append(response.Answer, rr)
                }
            }
        }

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä¸”å¯ç”¨äº†è½¬å‘
        if len(response.Answer) == 0 && forward {
            // è½¬å‘åˆ°ä¸Šæ¸¸ DNS
            return d.forwardQuery(m)
        }
    }
    return response
}
```

**æ•°æ®æµè½¬**ï¼š
- DNS é—®é¢˜ â†’ æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…
- åŒ¹é…ç»“æœ â†’ DNS è®°å½•
- DNS è®°å½• â†’ DNS å“åº”
- DNS å“åº” â†’ å®¢æˆ·ç«¯

## 6. æ–‡ä»¶ä¼ è¾“æµç¨‹

### 6.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph SENDER["ğŸ“¤ å‘é€æ–¹ï¼ˆèŠ‚ç‚¹ Aï¼‰"]
        direction TB
        A1["1ï¸âƒ£ å…±äº«æ–‡ä»¶<br/>Share File"]
        A2["2ï¸âƒ£ å…¬å‘Šæ–‡ä»¶ä¿¡æ¯åˆ°è´¦æœ¬<br/>Announce to Ledger"]
        A3["3ï¸âƒ£ ç­‰å¾…æ¥æ”¶æ–¹è¿æ¥<br/>Wait for Connection"]
    end

    subgraph RECEIVER["ğŸ“¥ æ¥æ”¶æ–¹ï¼ˆèŠ‚ç‚¹ Bï¼‰"]
        direction TB
        B1["4ï¸âƒ£ æŸ¥è¯¢æ–‡ä»¶åˆ—è¡¨<br/>Query File List"]
        B2["5ï¸âƒ£ ä»è´¦æœ¬è·å–æ–‡ä»¶ä¿¡æ¯<br/>Get File Info from Ledger"]
        B3["6ï¸âƒ£ å»ºç«‹ P2P è¿æ¥<br/>Establish P2P Connection"]
        B4["7ï¸âƒ£ è¯·æ±‚æ–‡ä»¶ä¼ è¾“<br/>Request File Transfer"]
    end

    subgraph TRANSFER["ğŸ”„ æ–‡ä»¶ä¼ è¾“"]
        direction TB
        T1["8ï¸âƒ£ èŠ‚ç‚¹ A è¯»å–å¹¶å‘é€æ–‡ä»¶<br/>Read and Send File"]
        T2["9ï¸âƒ£ èŠ‚ç‚¹ B æ¥æ”¶æ–‡ä»¶æ•°æ®<br/>Receive File Data"]
        T3["âœ… æ–‡ä»¶ä¼ è¾“å®Œæˆ<br/>Transfer Complete"]
    end

    A1 -->|"æ–‡ä»¶å‡†å¤‡"| A2
    A2 -->|"å…¬å‘Šå‘å¸ƒ"| A3
    B1 -->|"æŸ¥è¯¢è¯·æ±‚"| B2
    B2 -->|"æ–‡ä»¶ä¿¡æ¯"| B3
    B3 -->|"P2P æµ"| B4
    A3 -.->|"ç­‰å¾…"| B3
    B4 -->|"ä¼ è¾“è¯·æ±‚"| T1
    T1 -->|"æ–‡ä»¶æµ"| T2
    T2 -->|"æ•°æ®æ¥æ”¶"| T3

    %% æ ·å¼å®šä¹‰
    classDef senderStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef receiverStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef transferStyle fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px,color:#4A148C
    classDef finalStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20

    class A1,A2,A3 senderStyle
    class B1,B2,B3,B4 receiverStyle
    class T1,T2 transferStyle
    class T3 finalStyle
```

### 6.2 è¯¦ç»†è¯´æ˜

#### å‘é€æ–¹ï¼šæ–‡ä»¶å…±äº«

```go
// pkg/services/files.go
func ShareFile(ll log.StandardLogger, announcetime time.Duration, fileID, filepath string) ([]node.Option, error) {
    // éªŒè¯æ–‡ä»¶å­˜åœ¨
    _, err := os.Stat(filepath)
    if err != nil {
        return nil, err
    }

    return []node.Option{
        node.WithNetworkService(
            SharefileNetworkService(announcetime, fileID),
        ),
        node.WithStreamHandler(protocol.FileProtocol,
            func(n *node.Node, l *blockchain.Ledger) func(stream network.Stream) {
                return func(stream network.Stream) {
                    // éªŒè¯æ¥æ”¶æ–¹
                    _, found := l.GetKey(protocol.UsersLedgerKey, stream.Conn().RemotePeer().String())
                    if !found {
                        stream.Reset()
                        return
                    }

                    // å‘é€æ–‡ä»¶
                    f, err := os.Open(filepath)
                    if err != nil {
                        return
                    }
                    io.Copy(stream, f)
                    f.Close()
                    stream.Close()
                }
            }),
    }, nil
}
```

**æ•°æ®æµè½¬**ï¼š
- æ–‡ä»¶è·¯å¾„ â†’ æ–‡ä»¶å¥æŸ„
- æ–‡ä»¶å¥æŸ„ â†’ P2P æµ
- P2P æµ â†’ æ¥æ”¶æ–¹

#### æ¥æ”¶æ–¹ï¼šæ–‡ä»¶æ¥æ”¶

```go
// cmd/file.go
func FileReceive(c *cli.Context) error {
    // ä»åŒºå—é“¾è·å–æ–‡ä»¶ä¿¡æ¯
    files := ledger.CurrentData()[protocol.FilesLedgerKey]
    for k, v := range files {
        file := &types.File{}
        v.Unmarshal(file)
        if file.Name == fileID {
            // å»ºç«‹è¿æ¥
            peerID, _ := peer.Decode(file.PeerID)
            stream, err := node.Host().NewStream(context.Background(), peerID, protocol.FileProtocol)
            if err != nil {
                return err
            }

            // æ¥æ”¶æ–‡ä»¶
            f, err := os.Create(outputPath)
            if err != nil {
                return err
            }
            io.Copy(f, stream)
            f.Close()
            stream.Close()
            break
        }
    }
    return nil
}
```

**æ•°æ®æµè½¬**ï¼š
- æ–‡ä»¶ ID â†’ è´¦æœ¬æŸ¥è¯¢
- è´¦æœ¬æ•°æ® â†’ PeerID
- PeerID â†’ P2P è¿æ¥
- P2P æµ â†’ æ–‡ä»¶æ•°æ®

## 7. æœåŠ¡å‘ç°æµç¨‹

### 7.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph PROVIDER["ğŸ”§ æœåŠ¡æä¾›è€…ï¼ˆèŠ‚ç‚¹ Aï¼‰"]
        direction TB
        A1["1ï¸âƒ£ æ³¨å†ŒæœåŠ¡<br/>Register Service"]
        A2["2ï¸âƒ£ æ·»åŠ æœåŠ¡ä¿¡æ¯åˆ°è´¦æœ¬<br/>Add Service to Ledger"]
        A3["3ï¸âƒ£ å®šæœŸå…¬å‘ŠæœåŠ¡ï¼ˆå¿ƒè·³ï¼‰<br/>Announce Service (Heartbeat)"]
    end

    subgraph CONSUMER["ğŸ‘¤ æœåŠ¡æ¶ˆè´¹è€…ï¼ˆèŠ‚ç‚¹ Bï¼‰"]
        direction TB
        B1["4ï¸âƒ£ æŸ¥è¯¢æœåŠ¡åˆ—è¡¨<br/>Query Service List"]
        B2["5ï¸âƒ£ ä»è´¦æœ¬è·å–æ‰€æœ‰æœåŠ¡<br/>Get All Services from Ledger"]
        B3["6ï¸âƒ£ ç­›é€‰ç›®æ ‡æœåŠ¡<br/>Filter Target Service"]
        B4["7ï¸âƒ£ å»ºç«‹åˆ°æœåŠ¡æä¾›è€…çš„è¿æ¥<br/>Connect to Provider"]
        B5["âœ… ä½¿ç”¨æœåŠ¡<br/>Use Service"]
    end

    A1 -->|"æœåŠ¡æ³¨å†Œ"| A2
    A2 -->|"æœåŠ¡ä¿¡æ¯"| A3
    A3 -.->|"å®šæœŸå…¬å‘Š"| B2
    B1 -->|"æŸ¥è¯¢è¯·æ±‚"| B2
    B2 -->|"æœåŠ¡åˆ—è¡¨"| B3
    B3 -->|"ç›®æ ‡æœåŠ¡"| B4
    B4 -->|"P2P è¿æ¥"| B5

    %% æ ·å¼å®šä¹‰
    classDef providerStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef consumerStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef finalStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20

    class A1,A2,A3 providerStyle
    class B1,B2,B3,B4 consumerStyle
    class B5 finalStyle
```

### 7.2 è¯¦ç»†è¯´æ˜

#### æœåŠ¡æ³¨å†Œå’Œå…¬å‘Š

```go
// pkg/services/services.go
func RegisterService(ll log.StandardLogger, announcetime time.Duration, serviceID, dstaddress string) []node.Option {
    return []node.Option{
        node.WithStreamHandler(protocol.ServiceProtocol, func(n *node.Node, l *blockchain.Ledger) func(stream network.Stream) {
            return func(stream network.Stream) {
                // éªŒè¯è°ƒç”¨è€…
                _, found := l.GetKey(protocol.UsersLedgerKey, stream.Conn().RemotePeer().String())
                if !found {
                    stream.Reset()
                    return
                }

                // è¿æ¥åˆ°ç›®æ ‡æœåŠ¡
                c, err := net.Dial("tcp", dstaddress)
                if err != nil {
                    stream.Reset()
                    return
                }

                // åŒå‘è½¬å‘
                closer := make(chan struct{}, 2)
                go copyStream(closer, stream, c)
                go copyStream(closer, c, stream)
                <-closer

                stream.Close()
                c.Close()
            }
        }),
        node.WithNetworkService(ExposeNetworkService(announcetime, serviceID)),
    }
}
```

**æ•°æ®æµè½¬**ï¼š
- æœåŠ¡é…ç½® â†’ è´¦æœ¬è®°å½•
- è´¦æœ¬è®°å½• â†’ å®šæœŸå…¬å‘Š
- æœåŠ¡è¯·æ±‚ â†’ æµå¤„ç†å™¨
- æµå¤„ç†å™¨ â†’ ç›®æ ‡æœåŠ¡

## 8. èŠ‚ç‚¹å‘ç°æµç¨‹

### 8.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph DISCOVERY["ğŸ” èŠ‚ç‚¹å‘ç°æµç¨‹"]
        direction TB
        A["1ï¸âƒ£ èŠ‚ç‚¹å¯åŠ¨<br/>Node Start"]
        B["2ï¸âƒ£ è®¡ç®— OTP ä¼šåˆç‚¹<br/>Calculate OTP Rendezvous"]
        C["3ï¸âƒ£ åŠ å…¥ DHT ç½‘ç»œ<br/>Join DHT Network"]
        D["4ï¸âƒ£ å…¬å‘Šè‡ªå·±çš„å­˜åœ¨<br/>Announce Presence"]
        E["5ï¸âƒ£ æŸ¥æ‰¾å…¶ä»–èŠ‚ç‚¹<br/>Find Other Nodes"]
        F{"6ï¸âƒ£ å‘ç°æ–°èŠ‚ç‚¹ï¼Ÿ<br/>New Node Found?"}
        F1["âœ… å»ºç«‹è¿æ¥<br/>Establish Connection"]
        F2["â³ ç»§ç»­ç­‰å¾…<br/>Continue Waiting"]
        G["7ï¸âƒ£ è¿æ¥å»ºç«‹<br/>Connection Established"]
        H["8ï¸âƒ£ åŒæ­¥åŒºå—é“¾è´¦æœ¬<br/>Sync Blockchain Ledger"]
        I["âœ… èŠ‚ç‚¹åŠ å…¥ç½‘ç»œ<br/>Node Joined Network"]
    end

    A -->|"å¯åŠ¨å®Œæˆ"| B
    B -->|"ä¼šåˆç‚¹è®¡ç®—"| C
    C -->|"DHT å¼•å¯¼"| D
    D -->|"å­˜åœ¨å…¬å‘Š"| E
    E -->|"èŠ‚ç‚¹æŸ¥è¯¢"| F
    F -->|"å‘ç°èŠ‚ç‚¹"| F1
    F -->|"æœªå‘ç°"| F2
    F2 -.->|"é‡è¯•"| E
    F1 -->|"è¿æ¥æˆåŠŸ"| G
    G -->|"è¿æ¥å°±ç»ª"| H
    H -->|"è´¦æœ¬åŒæ­¥"| I

    %% æ ·å¼å®šä¹‰
    classDef stepStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef decisionStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef successStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20
    classDef waitStyle fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px,color:#4A148C

    class A,B,C,D,E,G,H stepStyle
    class F decisionStyle
    class F1,I successStyle
    class F2 waitStyle
```

### 8.2 è¯¦ç»†è¯´æ˜

#### DHT å‘ç°

```go
// pkg/discovery/dht.go
func (d *DHT) announceRendezvous(c log.StandardLogger, ctx context.Context, host host.Host, kademliaDHT *dht.IpfsDHT) {
    // å¼•å¯¼èŠ‚ç‚¹
    d.bootstrapPeers(c, ctx, host)

    // è·å–ä¼šåˆç‚¹
    rv := d.Rendezvous()
    d.rendezvousHistory.Add(rv)

    // å…¬å‘Šå’Œå‘ç°
    for _, r := range d.rendezvousHistory.Data {
        d.announceAndConnect(c, ctx, kademliaDHT, host, r)
    }
}

func (d *DHT) announceAndConnect(c log.StandardLogger, ctx context.Context, kademliaDHT *dht.IpfsDHT, host host.Host, rendezvous string) {
    // å…¬å‘Šè‡ªå·±
    _, err := kademliaDHT.Provide(ctx, discovery.RendezvousNamespace(rendezvous))
    if err != nil {
        c.Debugf("å…¬å‘Šå¤±è´¥: %v", err)
    }

    // å‘ç°å…¶ä»–èŠ‚ç‚¹
    peers, err := kademliaDHT.FindPeers(ctx, discovery.RendezvousNamespace(rendezvous))
    if err != nil {
        c.Debugf("å‘ç°å¤±è´¥: %v", err)
        return
    }

    // è¿æ¥å‘ç°çš„èŠ‚ç‚¹
    for _, p := range peers {
        if p.ID == host.ID() {
            continue
        }
        host.Connect(ctx, p)
    }
}
```

**æ•°æ®æµè½¬**ï¼š
- OTP å¯†é’¥ â†’ ä¼šåˆç‚¹å­—ç¬¦ä¸²
- ä¼šåˆç‚¹ â†’ DHT å‘½åç©ºé—´
- DHT å‘½åç©ºé—´ â†’ èŠ‚ç‚¹å‘ç°
- å‘ç°ç»“æœ â†’ P2P è¿æ¥

## 9. ä¿¡ä»»åŒºåŸŸè®¤è¯æµç¨‹

### 9.1 æµç¨‹å›¾

```mermaid
flowchart TD
    subgraph NODE_A["ğŸ–¥ï¸ èŠ‚ç‚¹ Aï¼ˆè¯·æ±‚æ–¹ï¼‰"]
        direction TB
        A1["1ï¸âƒ£ å°è¯•åŠ å…¥ç½‘ç»œ<br/>Try to Join Network"]
        A2["4ï¸âƒ£ æ¥æ”¶è®¤è¯æŒ‘æˆ˜<br/>Receive Challenge"]
        A3["5ï¸âƒ£ å“åº”æŒ‘æˆ˜<br/>Respond to Challenge"]
    end

    subgraph NODE_B["ğŸ–¥ï¸ èŠ‚ç‚¹ Bï¼ˆå®ˆæŠ¤è€…ï¼‰"]
        direction TB
        B1["2ï¸âƒ£ å¯¹ç­‰å®ˆæŠ¤è€…æ¥æ”¶æ¶ˆæ¯<br/>Peer Guardian Receives"]
        B2{"3ï¸âƒ£ æ£€æŸ¥ä¿¡ä»»åŒºåŸŸ<br/>Check Trust Zone"}
        B2a["âœ… å…è®¸è¿æ¥<br/>Allow Connection"]
        B2b["ğŸ“¤ å‘èµ·è®¤è¯æŒ‘æˆ˜<br/>Send Challenge"]
        B3["6ï¸âƒ£ éªŒè¯å“åº”<br/>Verify Response"]
        B4{"7ï¸âƒ£ éªŒè¯é€šè¿‡ï¼Ÿ<br/>Verify Passed?"}
        B4a["âœ… æ·»åŠ åˆ°ä¿¡ä»»åŒºåŸŸ<br/>Add to Trust Zone"]
        B4b["âŒ æ‹’ç»è¿æ¥<br/>Reject Connection"]
    end

    subgraph RESULT["ğŸ¯ è¿æ¥ç»“æœ"]
        direction TB
        R1["âœ… è¿æ¥å»ºç«‹<br/>Connection Established"]
        R2["âŒ è¿æ¥æ‹’ç»<br/>Connection Rejected"]
    end

    A1 -->|"åŠ å…¥è¯·æ±‚"| B1
    B1 -->|"æ¶ˆæ¯å¤„ç†"| B2
    B2 -->|"åœ¨ä¿¡ä»»åŒºåŸŸ"| B2a
    B2 -->|"ä¸åœ¨ä¿¡ä»»åŒºåŸŸ"| B2b
    B2b -->|"æŒ‘æˆ˜æ¶ˆæ¯"| A2
    A2 -->|"æ¥æ”¶æŒ‘æˆ˜"| A3
    A3 -->|"å“åº”æ¶ˆæ¯"| B3
    B3 -->|"å“åº”éªŒè¯"| B4
    B4 -->|"éªŒè¯é€šè¿‡"| B4a
    B4 -->|"éªŒè¯å¤±è´¥"| B4b
    B2a -->|"å…è®¸"| R1
    B4a -->|"æ·»åŠ ä¿¡ä»»"| R1
    B4b -->|"æ‹’ç»"| R2

    %% æ ·å¼å®šä¹‰
    classDef nodeAStyle fill:#E3F2FD,stroke:#1976D2,stroke-width:2px,color:#1565C0
    classDef nodeBStyle fill:#FFF3E0,stroke:#F57C00,stroke-width:2px,color:#E65100
    classDef decisionStyle fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px,color:#4A148C
    classDef successStyle fill:#E8F5E9,stroke:#388E3C,stroke-width:3px,color:#1B5E20
    classDef failStyle fill:#FFEBEE,stroke:#C62828,stroke-width:2px,color:#B71C1C

    class A1,A2,A3 nodeAStyle
    class B1,B3 nodeBStyle
    class B2,B4 decisionStyle
    class B2a,B4a,R1 successStyle
    class B4b,R2 failStyle
```

### 9.2 è¯¦ç»†è¯´æ˜

#### è®¤è¯æŒ‘æˆ˜

```go
// pkg/trustzone/peerguardian.go
func (pg *PeerGuardian) ReceiveMessage(l *blockchain.Ledger, m *hub.Message, c chan *hub.Message) error {
    pg.logger.Debug("å¯¹ç­‰èŠ‚ç‚¹å®ˆæŠ¤è€…æ”¶åˆ°æ¥è‡ª", m.SenderID, "çš„æ¶ˆæ¯")

    for _, a := range pg.authProviders {
        // æ£€æŸ¥æ˜¯å¦å·²åœ¨ä¿¡ä»»åŒºåŸŸ
        _, exists := l.GetKey(protocol.TrustZoneKey, m.SenderID)
        trustAuth := l.CurrentData()[protocol.TrustZoneAuthKey]

        if !exists && a.Authenticate(m, c, trustAuth) {
            // è®¤è¯æˆåŠŸï¼Œæ·»åŠ åˆ°ä¿¡ä»»åŒºåŸŸ
            l.Persist(context.Background(), 5*time.Second, 120*time.Second, protocol.TrustZoneKey, m.SenderID, "")
            return nil
        }
    }

    return nil
}
```

**æ•°æ®æµè½¬**ï¼š
- èŠ‚ç‚¹æ¶ˆæ¯ â†’ è®¤è¯æä¾›è€…
- è®¤è¯æä¾›è€… â†’ è®¤è¯é€»è¾‘
- è®¤è¯ç»“æœ â†’ ä¿¡ä»»åŒºåŸŸ

## 10. æ•°æ®æµè½¬å›¾

### 10.1 æ•´ä½“æ•°æ®æµ

```mermaid
graph LR
    A[åº”ç”¨] --> B[VPN æ¥å£]
    B --> C[æ•°æ®åŒ…è§£æ]
    C --> D[ç›®æ ‡ IP æŸ¥æ‰¾]
    D --> E[åŒºå—é“¾è´¦æœ¬]
    E --> F[PeerID è·å–]
    F --> G[P2P æµ]
    G --> H[ç›®æ ‡èŠ‚ç‚¹]
    H --> I[ç›®æ ‡ VPN æ¥å£]
    I --> J[ç›®æ ‡åº”ç”¨]

    K[æœåŠ¡æ³¨å†Œ] --> L[åŒºå—é“¾è´¦æœ¬]
    M[æœåŠ¡æŸ¥è¯¢] --> L
    L --> N[æœåŠ¡åˆ—è¡¨]

    O[èŠ‚ç‚¹å‘ç°] --> P[DHT]
    P --> Q[æ–°èŠ‚ç‚¹]
    Q --> R[P2P è¿æ¥]
    R --> S[è´¦æœ¬åŒæ­¥]
```

### 10.2 æ¨¡å—é—´æ•°æ®æµ

```mermaid
graph TB
    subgraph "åº”ç”¨å±‚"
        APP1[åº”ç”¨ A]
        APP2[åº”ç”¨ B]
    end

    subgraph "VPN å±‚"
        VPN1[VPN æ¥å£ A]
        VPN2[VPN æ¥å£ B]
    end

    subgraph "æ ¸å¿ƒå±‚"
        NODE1[èŠ‚ç‚¹ A]
        NODE2[èŠ‚ç‚¹ B]
        LEDGER[åŒºå—é“¾è´¦æœ¬]
        HUB[æ¶ˆæ¯ä¸­å¿ƒ]
    end

    subgraph "ç½‘ç»œå±‚"
        P2P[P2P ç½‘ç»œ]
    end

    APP1 --> VPN1
    APP2 --> VPN2

    VPN1 --> NODE1
    VPN2 --> NODE2

    NODE1 --> LEDGER
    NODE2 --> LEDGER

    NODE1 --> HUB
    NODE2 --> HUB

    NODE1 --> P2P
    NODE2 --> P2P

    P2P --> HUB
```

## 11. æ€»ç»“

EdgeVPN çš„æ•°æ®æµç¨‹æ¶‰åŠå¤šä¸ªæ¨¡å—ä¹‹é—´çš„ç´§å¯†åä½œã€‚ä»èŠ‚ç‚¹å¯åŠ¨åˆ°æ•°æ®åŒ…è½¬å‘ï¼Œä»æœåŠ¡å‘ç°åˆ°ä¿¡ä»»è®¤è¯ï¼Œæ¯ä¸ªæµç¨‹éƒ½ç»è¿‡ç²¾å¿ƒè®¾è®¡ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¯é æ€§ã€å®‰å…¨æ€§å’Œæ€§èƒ½ã€‚ç†è§£è¿™äº›æ•°æ®æµç¨‹å¯¹äºå¼€å‘å’Œç»´æŠ¤ EdgeVPN è‡³å…³é‡è¦ã€‚
